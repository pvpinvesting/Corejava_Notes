***************
26-Sept-2023
***************
In Java there are 2 types of modifiers:
	Non-Access Modifiers:
		static, final, abstract, synchronized, native, volatile,transient
		& strictfp - not used now.
	Access Modifiers:
	
Public: 
			The access level of a public modifier is everywhere. It can be accessed from within the class, outside the class, within the package and outside the package.
			Which uses for variables, methods, constructor, class & interface etc.
Protected: 
			The access level of a protected modifier is within the package and outside the package through child class. If you do not make the child class, it cannot be accessed from outside the package.
			Which uses for variables, methods and constructor.
			
Default: 
			The access level of a default modifier is only within the package. It cannot be accessed from outside the package. If you do not specify any access level, it will be the default.
			
			Which uses for variables, methods & class etc.
Private: 
			The access level of a private modifier is only within the class. It cannot be accessed from outside the class.
			Which uses for variables, methods and constructor.
			

Note: 
		Access specifiers can't applicable to local variables.
		We can't mention a class as a private or protected, if it is an outer class.
		
Can we mention a class as private?
	We can mention a class as private if it is inner class.
	
	

Static : Static variables are shared by all the objects.
		 static variables can be called with class name.
		 can be called with object reference but avoid it.
		 
		 If we want to call non-static methods then require object of the class.
		 

Access Modifiers in Java are used to control the visibility of fields, methods, classes and constructors.

Native Keyword in Java:

	The native keyword in Java is applied to a method to indicate that the method is implemented in native code using JNI (Java Native Interface). The native keyword is a modifier that is applicable only for methods, and we can’t apply it anywhere else. The methods which are implemented in C, C++ are called native methods or foreign methods.

Volatile Keyword in Java:

	Volatile keyword is used to modify the value of a variable by different threads. It is also used to make classes thread safe. It means that multiple threads can use a method and instance of the classes at the same time without any problem. The volatile keyword can be used either with primitive type or objects.

	The volatile keyword does not cache the value of the variable and always read the variable from the main memory.	

Example
	
	class Test{  
		static int var=5;  
	}  
	
	In the above example, assume that two threads are working on the same class. Both threads run on different processors where each thread has its local copy of var. If any thread modifies its value, the change will not reflect in the original one in the main memory. It leads to data inconsistency because the other thread is not aware of the modified value.
	
	class Test{  
		static volatile int var =5;  
	}  

	In the above example, static variables are class members that are shared among all objects. There is only one copy in the main memory. The value of a volatile variable will never be stored in the cache. All read and write will be done from and to the main memory.

Java Strictfp Keyword:
	Java strictfp keyword ensures that you will get the same result on every platform if you perform operations in the floating-point variable.
		 
		 

27-September-2023

***************
static keyword:
***************

The static keyword in Java is mainly used for memory management.It is a non-access modifier in Java that can apply with variables, methods, blocks, and nested classes. 
Which is used for a constant variable or a method that is the same for every instance of a class.

The static keyword is a non-access modifier in Java that is applicable for the following: 

Variables
Methods
Blocks
Inner Classes

static variables:
				When a variable is declared as static, then a single copy of the variable is created and shared among all objects at the class level. Static variables are, essentially, global variables. All instances of the class share the same static variable.
static method:
				If you apply static keyword with any method, it is known as static method.
				A static method belongs to the class rather than the object of a class.
				A static method can be invoked without the need for creating an instance of a class.
				A static method can access static data member and can change the value of it.
static block:
				Is used to initialize the static data member.
				It is executed before the main method at the time of classloading.
				
static Classes: 
				A class can be made static only if it is a nested class. We cannot declare a top-level class with a static modifier but can declare nested classes as static. Such types of classes are called Nested static classes. Nested static class doesn’t need a reference of Outer class. In this case, a static class cannot access non-static members of the Outer class. 


Features of static keyword:

Shared memory allocation: 
						Static variables and methods are allocated memory space only once during the execution of the program. This memory space is shared among all instances of the class, which makes static members useful for maintaining global state or shared functionality.

Accessible without object instantiation: 
						Static members can be accessed without the need to create an instance of the class. This makes them useful for providing utility functions and constants that can be used across the entire program.

Associated with class, not objects: 
						Static members are associated with the class, not with individual objects. This means that changes to a static member are reflected in all instances of the class, and that you can access static members using the class name rather than an object reference.

Cannot access non-static members: 
						Static methods and variables cannot access non-static members of a class, as they are not associated with any particular instance of the class.

Can be overloaded, but not overridden: 
						Static methods can be overloaded, which means that you can define multiple methods with the same name but different parameters. However, they cannot be overridden, as they are associated with the class rather than with a particular instance of the class.

https://meet.google.com/rud-wgoh-pxj

How to load a class into memory without creating object.
	Class.forName("com.grats.st.variable.Company");


*********************
28-Sept-2023:
*********************

Inner Class in Java:
		Java inner class or nested class is a class that is declared inside the class or interface. We use inner classes to logically group classes and interfaces in one place to be more readable and maintainable. Additionally, it can access all the members of the outer class, including private data members and methods.

There are two types of nested classes non-static and static nested classes.

Non-static nested class (inner class):
	Member inner class:
		
		Syntax:
		
			class Java_Outer_class{  
			 //code  
			 class Java_Inner_class{  
			  //code  
			 }  
			}  
		
	Local inner class:
		A class i.e., created inside a method, is called local inner class in java. 
		
			class Java_Outer_class{  
			 //code  
				void methodA(){
					class Java_Inner_class{  
						//code  
					}	
				}
  			} 
		
	Anonymous inner class:
		Java anonymous inner class is an inner class without a name and for which only a single object is created.
		
		interface Employee{
			public abstract void showEmployee();
		}
		
		psvm(String[] args){
			Employee emp=new Employee(){
				public void showEmployee(){
					syso("showEmployee()");
				}
			};
		}
	
Static nested class:
	A static inner class is a nested class which is a static member of the outer class. It can be accessed without instantiating the outer class, using other static members. Just like static members, a static nested class does not have access to the instance variables and methods of the outer class. The syntax of static nested class is as follows −

Syntax:
	
	class MyOuter {
	   static class Nested_Demo {
	   }
	}

final Keyword: Notes should take from PPT.


*************
03-Oct-2028:
*************


Exception and Exception Handling:

Types of Erros:
	1. Compile Time Error
	2. Runtime Error
	
1. Compile Time Error:
	
		Any error that occurs at the time of compilation then we call that as a Compile Time Error.

		Compile Time Errors are those errors which prevent the code from running because of following reasons:

			i) It can occur because of wrong syntax.
			ii) It can occur because the environment required for executing a statement is not existing.
			iii)It may occur because of the checked exceptions.
			

2. Logical and Runtime Error:
	Any error that occurs at the time of execution of the program then we call it a Runtime error.

	=> Runtime errors may occur because of logical errors.
	=> Any wrong logic which leads to wrong outputs can be called a logical error.
	=> A Runtime error occurs only because of the logical errors. But every logical error would not lead to a runtime error.
	=> When JVM enters into the state of ambiguity (i.e., confusion) is known as runtime error.
	=> A Runtime error leads to an abnormal termination of the program.
		What is abnormal termination?
		The concept of termination of the program in the middle of its execution without executing the remaining statements of the program is known as abnormal termination.
		
		statement 1;
		statement 2;
		statement 3;
		statement 4;//If any errors occurs then terminate the program here.
		statement 5;
		statement 6;
		
	=> In order to represent each and every logical error there would be a corresponding exception class.
	
		Exception classes: The set of classes which are exclusively designed for representing logical errors are known as exception classes.
		
		Exception Hierarchy :
		
	What is an Exception?
	
		=> An exception is an event that occurs during the execution of a program that disrupts the normal flow of the program's instructions. In Java, exceptions are objects that describe an exceptional (error) condition that has occurred in a piece of code.
		=> It is an object which is thrown at runtime.
		=> Exceptions are the objects representing the corresponding logical and runtime errors.
		=> Any object created by the jvm for representing the corresponding logical or runtime error can be called as an Exception.
		
*************
04-Oct-2023:
*************
	=> An exception is a problem that arises during the execution of a program. It can occur for various reasons:
		-> A user has entered a invalid data.
		-> If trying to read a file but which is not present then we get the FileNotFoundException.
		-> A network connection has been lost in the middle of communications.
		-> The JVM has run out of memory. 

	So if an exception is not handled, it may lead to a system failure. That is why handling an exception is very important.

Exception Hierarchy :

	All exception and error types are subclasses of class Throwable, which is the base class of hierarchy.
	One branch is headed by Error which occurs at run-time and other by Exception that can happen either at compile time or runtime.

	Exception :
		All the classes represent simple logical errors.
		
		We have 2 types of Exceptions under Exception
			1. Checked Exception:
				It is an exception that occurs at compile time, also called compile time exceptions. If some code within a method throws a checked exception, then the method must either handle the exception.
				All subclasses of Exception class but which are not subclasses of Runtime Exception are Checked Exception classes.
				Example: ClassNotFoundException, IOException, SQLException ...

			2. Unchecked Exception:
				It is an exception that occurs at the time of execution. These are called Runtime exceptions.
				All the subclasses of RuntimeException are unchecked exceptions.
				Example: ArithmeticException, NullpointerException, NumberFormatException ...

	Error : 
		An Error is used by the Java run-time system (JVM) to indicate errors that are associated with the run-time environment (JRE).
		All the classes represent serious logical errors.
		xamples for it. VirtualMemoryError, OutOfMemoryError and StackOverflowError

	Difference between Exceptions and Errors:
		Exceptions:
			=> Possible to recover from Exceptions.
			=> Exceptions can be either checked or unchecked exceptions
			=> Can occur at compile time or run time.
			=> Caused by the application itself.

		Errors:
			=> Impossible to recover from an error.
			=> Errors are of type unchecked.
			=> Can occur at run time.
			=> Caused by the application running environment.



Exception Handling:

		=> The Exception Handling in Java is one of the powerful mechanisms to handle the runtime errors so that normal flow of the application can be maintained.
		=> The code which is prone to exceptions is placed in the try block. When an exception occurs, that exception is handled by the catch block associated with it.
		Every try block should be immediately followed either by a catch block or finally block.

		Syntax:
			try {
			  //  Protected  Code
			} catch (ExceptionName e1) {
			  // Catch block
			}
		
		or 
			try {
			  //  Protected  Code
			} finally {
			  // finally block 
			}
		

		try:
			The functionality of the try keyword is only to identify a logical error or an exception and transfer the control along with the exception identified to the catch block by suspending the execution of try block.
			A try block must follow catch blocks or finally block or both.
			
			Nested try block:
				try block within a try block is known as nested try block in java.

		catch:
			The functionality of the catch is to receive an exception that is identified by the try and assign that exception object to the reference of the corresponding exception class and handle it.
			This block must have the try block.

			Multiple Catch Blocks
			=> A try block can be followed by multiple catch blocks. The syntax for multiple catch blocks looks like the following −
			try {
			  // Protected code
			} catch (ExceptionType1 e1) {
			  // Catch block
			} catch (ExceptionType2 e2) {
			  // Catch block
			} catch (ExceptionType3 e3) {
			  // Catch block
			}
		
finally:
			A finally block contains all the crucial statements that must be executed whether an exception occurs or not. The statements present in this block will always execute, regardless an exception occurs in the try block or not such as closing a connection, stream etc. 
			

System.exit(0):			
			System. exit(0) method terminates JVM which results in termination of the currently running program too. Status is the single parameter that the method takes. If the status is 0, it indicates the termination is successful. If exit(1) or exit(-1) or any non-zero value – indicates unsuccessful termination.
			
			the finally block will be executed even after a return statement in a method. If we call the System. exit() method explicitly in the finally block then only it will not be executed.
			
			There are few situations where the finally will not be executed like JVM crash, power failure, software crash and etc. Other than these conditions, the finally block will be always executed.
			
Unreachable block:
		The block of statements which are not going to get executed at any given point of time under any case are known as unreachable blocks.
		Unreachable blocks are not supported by Java.
		The catch block mentioned with the reference of the Exception class should and must always be the last catch block because Exception is the superclass of all exceptions.
		
		try {
			// Code 
		}catch(Exception e) {
		// exception handling.
		}catch(NullPointerException e) {
			// Unreachable block. 
		}

User-Defined Exception:
	Sometimes, the built in exceptions in Java are not able to describe a certain situation. In such cases, a user also can create exceptions which are called User-Defined exceptions.
	
	=> A user-defined exception must extend the Exception or RuntimeException class.
	=> The exception is thrown using the throw keyword.
	
	Syntax for user defined exception:
		public class MyException extends Exception{
			public MyException(String errMsg){
				super(errMsg);
			}
		}

	Syntax for throw an exception explicitly:
	
			throw new MyException("User-defined exception raised");


Difference between final, finally and finalize:

	Definition:	
				final: 	final is a keyword and access modifier that is used to restrict access to a class, method, or variable.
				finally: finally, block in Java Exception Handling executes the critical function whether or not the exception occurs
				finalize():	In Java, the finalize method is used to do cleanup procedures immediately before an object is garbage collected.
	
	Applicable to: 
				final: With classes, methods, and variables, the final keyword is utilized.
				finally:	In exception handling, the finally block is usually associated with the try and catch block.
				finalize():	The finalize() method is applied to objects.
				
	Functionality:
				final: 	(1) Once declared, the final variable is fixed and cannot be changed.
						(2) A subclass cannot override the final method.
						(3) The final class is not inheritable.
						
				finally:	
						(1) The finally block executes the critical code whether or not an exception occurs.
						(2) The finally block cleans up all of the resources that were used in the try block.
				finalize():	
							Before an item is destroyed, cleaning tasks are carried out using the finalize method.
							
	Execution:
				final: Only when we call the final method is it actually used.
				finally:	After the try-catch block, the finally block is carried out.
				finalize():	Just before the object is destroyed, the finalize method is called.
				
throws:
		throws is a keyword in Java that is used in the signature of a method to indicate that this method might throw one of the listed type exceptions. The caller to these methods has to handle the exception using a try-catch block. 
		
		Syntax:
				public void method1() throws IOException,SQLException{
					// code.
				}
		
		=> by using throws keyword can avoid try & catch block.
		=> throws keyword is required only for checked exceptions and usage of the throws keyword for unchecked exceptions is meaningless.
		=> With the help of the throws keyword, we can provide information to the caller of the method about the exception.
		
	Difference between throw & throws:
	
			throw															throws
	1. Java throw keyword is used to explicitly throw an exception 		1. Java throws keyword is used to declare an exception.
	2. checked exceptions can't be propagated using throw only.			2. checked exceptions can be propagated with throws.
	3. throw is followed by instance.									3. throws is followed by class.
	4. throw is used within the method.								4. throws is used with the method signature.
	5. We can't throw multiple exceptions.								5. We can declare multiple exceptions with throws in 
																			method signature.
																			Ex: public void myMethod() throws IOException,SQLException
																			
***************
06-Oct-2023
***************

String, StringBuffer & StringBuilder:

	Java provides 3 classes to represent a sequence of characters namely, String, StringBuffer and StringBuilder.
	It is very important for us as developers to know when to use which class.


java.lang.String: It is a sequence of characters. In Java, objects of String are immutable which means a constant and cannot be changed object state once created.

There are 2 ways can create a String object.

1) By string literal:
	String s1="Grats"; // In this case a new object created in String constant pool and referred with reference s1 variable.
	
	String s2="Grats"; // In this case since object with same content already available in String constant pool will return reference to the same instance s1.  
	
	Each time a string literal is created, the JVM checks the string literal pool first. If the string already exists in the string pool, a reference to the pooled instance returns. If the string does not exist in the pool, a new String object initializes and is placed in the pool.
	
2) By new keyword: 
	String s3=new String("Grats"); // In this case creates 2 objects one is in Heap memory and another one is in String constant pool. But s3 refers to the heap memory object.
	
String class have many useful methods to perform operations on sequence of characters.

	Method Name										Description
	
	int length()									Returns the length of this string.
	String substring(int beginIndex)				Returns a new string that is a substring of this string.
	String substring(int beginindex,int endindex)	Returns a new string that is a substring of this string.
	
	boolean isEmpty()                 				Returns true if, and only if, length() is 0.
	String concate(String str)                  	Concatenates the specified string to the end of this string.
	String toLowerCase()                       		Converts all of the characters in this String to lower case
	String toUpperCase()                  			Converts all of the characters in this String to upper case
	char charAt(int index)							Returns the char value at the specified index.
	int compareTo(String s)							Compares two strings lexicographically
	int compareToIgnoreCase(String s)				Compares two strings lexicographically, ignoring case differences.
	boolean equals(Object another)                  Compares this string to the specified object.
	boolean equalsIgnoreCase(String s)				Compares this String to another String, ignoring case considerations.
	boolean startsWith(String s)					Tests if this string starts with the specified prefix.
	boolean endsWith(String s)						Tests if this string ends with the specified suffix.
	int indexOf(String s)							Returns the index within this string of the first occurrence of the specified substring.
	int lastIndexOf(String s)						Returns the index within this string of the last occurrence of the specified character.
	String replace(CharSequence target, CharSequence replacement)					
													Replaces each substring of this string that matches the literal target sequence with the specified literal replacement sequence.
	String trim()									Returns a copy of the string, with leading and trailing whitespace omitted.
	String[] split(String regex)					Splits this string around matches of the given regular expression.

*****************
09-Oct-2023
*****************

java.lang.StringBuffer:	
						StringBuffer is a class in Java that represents a mutable sequence of characters. It provides an alternative to the immutable String class, allowing you to modify the contents of a string without creating a new object every time.
						
						StringBuffer objects are thread-safe, which means multiple threads can access it simultaneously
						
						Syntax:
								StringBuffer sb=new StringBuffer(); //By default initial capacity is 16
								Or
								StringBuffer sb=new StringBuffer(50);
								Or
								StringBuffer sb=new StringBuffer("Java");
								
								
	methods:
			append():	The append() method concatenates the given argument with this string.
			insert():	The insert() method inserts the given string with this string at the given position. 
			capacity():
					The capacity() method of the StringBuffer class returns the current capacity of the buffer. The default capacity of the buffer is 16. If the number of characters increases from its current capacity, it increases the capacity by (oldcapacity*2)+2.
					For instance, if your current capacity is 16, it will be (16*2)+2=34.
			replace():	The replace() method replaces the given string from the specified beginIndex and endIndex-1.
			delete():	The delete() method of the StringBuffer class deletes the string from the specified beginIndex to endIndex-1.
			reverse():	The reverse() method of the StringBuilder class reverses the current string. 
					
java.lang.StringBuilder:									
							The function of StringBuilder is very much similar to the StringBuffer class,StringBuilder class differs from the StringBuffer class on the basis of synchronization. String Builder is not thread-safe.
					
							The StringBuilder objects can be created same as StringBuffer and same methods present in this class.
							
	
Difference between String, StringBuffer and StringBuilder:
	Refer PPT.
	

Question:

1. Print a first non-repeated character from a String.

	Example : String is "Hello Hi"
			  Out put is: e
			  
2. Given string is a Palindrom or not
	Example : String is "madam"
				out put is: Given string is a palindrom
				

*****************
10-Oct-2023
*****************
Java arrays: 
			Java array is an object which contains elements of a similar data type. Additionally, The elements of an array are stored in a contiguous memory location. It is a data structure where we store similar elements. We can store only a fixed set of elements in a Java array.
			
			Java array is index-based, the first element of the array is stored at the 0th index, 2nd element is stored on 1st index and so on.
			
			Java array is an object which inherits the object class. We can store primitive values or objects in an array in Java.
			
		Types of Array in java
			Single Dimensional Array:	
				Syntax of array declartion:
					datatype[] ref-name;
					or
					datatype ref-name[];
					
				Syntax of array creation:
				
					datatype[] ref-name = {value1,value2,value3....valueN}; // if knows the values
					or 
					ref-name = new datatype[]{value1,value2,value3....valueN}; // if knows the values
					or 
					ref-name = new datatype[10]; // if we don't know the values then define a size.
			
			Multidimensional Array
			
			dataType[][] arrayRefVar; (or)  
			dataType [][]arrayRefVar; (or)  
			dataType arrayRefVar[][]; (or)  
			dataType []arrayRefVar[];
			
			Example:
				int[][] arr=new int[3][3];
	
	
	Arrays Types and Their Allowed Element Types:
	
			Array Types								Allowed Element Types
		Allowed Element Types					Any type which can be implicitly promoted to declared type.
		Object Type Arrays						Either declared type objects or it’s child class objects.
		Abstract Class Type Arrays				Its child-class objects are allowed.
		Interface Type Arrays					Its implementation class objects are allowed.
	
			
	Advantages:
			Code Optimization: It makes the code optimized, we can retrieve or sort the data efficiently.
			Random access: We can get any data located at an index position.
			
	Limitations of array:
			Size Limit: We can store only the fixed size of elements in the array. It doesn't grow its size at runtime.
			
			int[] a = new int[4];
			a.length = 10;         // error
			

java.util.Arrays:
		Class Arrays in package java.util has useful static methods for manipulating arrays. This class provides static methods to dynamically create and access Java arrays. It consists of only static methods and the methods of Object class.
		
		refer ppt.
		
*****************
11-Oct-2023
*****************
Variable Arguments (Varargs) in Java:

	Variable Arguments (Varargs) were introduced in JDK 5. From JDK 5 onwards, we can declare a method with a variable number of arguments. Such types of methods are called Varargs methods. The varargs feature offers a simpler, better option.

	public void fun(int... args) 
	{
	   // method body
	} 

	There can be only one variable argument in a method.
	Variable argument (Varargs) must be the last argument.

Enhanced for loop :
	Enhanced for loop is introduced since J2SE 5.0. It provides an alternative approach to traverse the array or collection in Java. It is mainly used to traverse the array or collection elements.
	
	Syntax:
		for(declaration : expression) {
			// Statements
		}
		
	Declaration − The newly declared block variable is of a type compatible with the elements of the array you are accessing.
	Expression − This evaluates to the array you need to loop through. The expression can be an array variable or method call that returns an array.
	
	Eample:
			int [] numbers = {10, 20, 30, 40, 50};
			for(int x : numbers ) {
					System.out.print( x );
					System.out.print(" ");
			}

	
Object class:
	Object class is present in java.lang package. Every class in Java is directly or indirectly derived from the Object class. If a class does not extend any other class then it is a direct child class of Object and if extends another class then it is indirectly derived. 
	Therefore the Object class methods are available to all Java classes. Hence Object class acts as a root of the inheritance hierarchy in any Java Program.
	1. tostring() 
	2. equals(Object obj)
	3. hashCode()
	4. getClass()
	5. clone()
	6. finalize()
	7. wait()
	8. notify()
	9. notifyAll()
	
	1. toString():
		// Default behavior of toString() is to print class name, then
		// @, then unsigned hexadecimal representation of the hash code of the object
				
		Object class defined toString() method like this:
				
			public String toString()
			{
				return getClass().getName() + "@" + Integer.toHexString(hashCode());
			}
			
			If we want to represent an object state as a string then we should override this method.
				
				
	2. equals(Object obj): 
		Object class defined equals() method like this:
		
			public boolean equals(Object obj) {
				return (this == obj);
			}
			
			So Object class equals() method implementation returns true only when both the references are pointing to same object.
			
	3. hashCode():
		
		Java Object hashCode() is a native method and returns the integer hash code value of the object. 
		
		The general contract of hashCode() method is:

			=>Multiple invocations of hashCode() should return the same integer value, unless the object property is modified that is being used in the equals() method.
			=>An object hash code value can change in multiple executions of the same application.
			=>If two objects are equal according to equals() method, then their hash code must be same.
			=>If two objects are unequal according to equals() method, their hash code are not required to be different. Their hash code value may or may-not be equal.
	
When to override equals() and hashCode() methods?
			When we override equals() method, it’s almost necessary to override the hashCode() method too so that their contract is not violated by our implementation.
			Note that your program will not throw any exceptions if the equals() and hashCode() contract is violated, if you are not planning to use the class as Hash table key, then it will not create any problem.
			If you are planning to use a class as Hash table key, then it’s must to override both equals() and hashCode() methods. 
			
	4. getClass():
			It returns the Class objects that represent the runtime class of this object.
			
	5. clone():
			Cloning is the process of creating a copy of an Object. Java Object class comes with native clone() method that returns the copy of the existing instance. Since Object is the base class in Java, all objects by default support cloning.
			
			If you want to use Java Object clone() method, you have to implement the java.lang.Cloneable marker interface. Otherwise, it will throw CloneNotSupportedException at runtime. 
			
			Also Object clone is a protected method, so you will have to override it.

*****************
12-OCT-2023
*****************
	
	6. finalize() :  Will discusss about this in Garbage collection.
	
	The following methods will discuss as part of threads concepts :
	
	7. wait()
	8. notify()
	9. notifyAll()




Marker interface in Java:
	It is an empty interface (no field or methods). Examples of marker interface are Serializable, Cloneable and Remote interface. All these interfaces are empty interfaces. 
	
	public interface Serializable 
	{
		// nothing here
	}
	
	Cloneable interface:
		Cloneable interface is present in java.lang package. There is a method clone() in Object class. A class that implements the Cloneable interface indicates that it is legal for clone() method to make a field-to-field copy of instances of that class. 
		 
		Invoking Object’s clone method on an instance of the class that does not implement the Cloneable interface results in an exception CloneNotSupportedException being thrown. 
		
	Serializable interface:
		Serializable interface is present in java.io package. 
		Classes that do not implement this interface will not have any of their object state serialized or deserialized. All subtypes of a serializable class are themselves serializable.
				
		Serialization and Deserialization:
			Serialization is a mechanism of converting the state of an object into a byte stream.
			Deserialization is the reverse process where the byte stream is used to recreate the actual Java object in memory.
			
		Advantages of Serialization 
			To save/persist state of an object. 
			To travel an object across a network.
			
		SerialVersionUID: The Serialization runtime associates a version number with each Serializable class called a SerialVersionUID, which is used during Deserialization to verify that sender and receiver of a serialized object have loaded classes for that object which are compatible with respect to serialization. If the receiver has loaded a class for the object that has different UID than that of corresponding sender’s class, the Deserialization will result in an InvalidClassException. 
			
		
		Point sto remember:
			1. If a parent class has implemented Serializable interface then child class doesn’t need to implement it but vice-versa is not true. 
			2. Only non-static data members are saved via Serialization process. 
			3. Static data members and transient data members are not saved via Serialization process. So, if you don’t want to save value of a 	non-static data member then make it transient. 
			4. Constructor of object is never called when an object is deserialized. 

		Refer image from ppt.
		
		
	Remote interface : 
		Remote interface is present in java.rmi package. A remote object is an object which is stored at one machine and accessed from another machine. So, to make an object a remote object, we need to flag it with Remote interface. 
		Here, Remote interface serves to identify interfaces whose methods may be invoked from a non-local virtual machine.Any object that is a remote object must directly or indirectly implement this interface.


Packages In Java:
	Package in Java is a mechanism to encapsulate a group of classes, sub packages and interfaces. All we need to do is put related classes into packages. After that, we can simply write an import class from existing packages and use it in our program. 

	Packages are used for:
		1. Preventing naming conflicts. 
			For example there can be two classes with name Employee in two packages, com.company.sales.Employee and com.company.marketing.Employee.
			
		2. Making searching/locating and usage of classes, interfaces, enumerations and annotations easier.
		
		3. Providing controlled access: protected and default have package level access control. A protected member is accessible by classes in the same package and its subclasses. A default member (without any access specifier) is accessible by classes in the same package only.
		
		4. Packages can be considered as data encapsulation (or data-hiding).
		
		https://grats.in.com
		
		com.in.grats
		
	Package naming conventions : 
					Package names are recommended to write in small case. 
					Packages are named in reverse order of domain names, 
					i.e., com.grats.practice,  com.grats.controller, com.grats.service, com.grats.dao
	
	Adding a class to a Package : 
			We can add more classes to a created package by using package name at the top of the program and saving it in the package directory. 
			
	Subpackages: 
		Packages that are inside another package are the subpackages. These are not imported by default, they have to imported explicitly. Also, members of a subpackage have no access privileges, i.e., they are considered as different package for protected and default access specifiers.
		
	Accessing classes of a package:
	
		import package.*;	// All the classes and interfaces of this package will be accessible but not subpackages.
			
		import package.classname;	// Only mentioned class of this package will be accessible.
		
							
		java.util.Arrays;	// import the Arrays class from util package.
		
		
		import java.util.*; 	// import all the classes from util package
		
	Types of packages:
		Built-in Packages:
		
			These packages consist of a large number of classes which are a part of Java API. Some of the commonly used built-in packages are:
			
			1) java.lang: Contains language support classes(e.g classed which defines primitive data types, math operations). This package is automatically imported.
			2)  java.io: Contains classes for supporting input / output operations.
			3)  java.util: Contains utility classes which implement data structures like Linked List, Dictionary and support ; for Date / Time operations.
			4)  java.applet: Contains classes for creating Applets.
			5)  java.awt: Contain classes for implementing the components for graphical user interfaces (like button , ;menus etc).
			6)  java.net: Contain classes for supporting networking operations.
		
		User-defined packages:
			These are the packages that are defined by the user. First we create a directory mypackage (name should be same as the name of the package). Then create the MyClass inside the directory with the first statement being the package names.
			
			/ Name of the package must be same as the directory
			// under which this file is saved
			package mypackage;

			public class MyClass
			{
				public void getNames(String s)
				{        
					System.out.println(s);        
				}
			}
	
	Using Static Import:
		Static import is a feature introduced in Java programming language ( versions 5 and above ) that allows members ( fields and methods ) defined in a class as public static to be used in Java code without specifying the class in which the field is defined.
		
		import static java.lang.System.*; 
   
		class StaticImportDemo 
		{ 
		   public static void main(String args[]) 
		   {       
				// We don't need to use 'System.out'  
				// as imported using static. 
				out.println("Hello"); 
		   } 
		} 
	
	Handling name conflicts
		The only time we need to pay attention to packages is when we have a name conflict . For example both, java.util and java.sql packages have a class named Date. 
		
		So if we import both packages in program as follows:
					
		import java.util.*;
		import java.sql.*;
		
		//And then use Date class, then we will get a compile-time error :

		Date today ; //ERROR-- java.util.Date or java.sql.Date?
	
	How to convert our project as a jar file.
		
		set PATH=C:\Program Files\Java\jdk-19\bin
		
		jar cf jar-file input-file(s)
		
		
		download the de-compiler from below url
		
		https://java-decompiler.github.io/
	
		C:\Users\Prakash\Downloads\jd-gui-windows-1.6.6\jd-gui-windows-1.6.6

*****************
13-Oct-2023
*****************

Garbage Collection:
		Garbage Collection is a process of reclaiming the runtime unused memory automatically. In other words, garbage collector finds the unused objects and deletes them to free up memory.
		
		In C/C++, a programmer is responsible to clean up the objects. But, in java it is performed automatically. So, java provides better memory management.
		
			
		Important Concepts Related to Garbage Collection in Java:
		
			1. Unreachable objects: 
					An object is said to be unreachable if it doesn’t contain any reference to it. 
					Integer i = new Integer(4); // the new Integer object is reachable  via the reference in 'i' 
					i = null;
					// the Integer object is no longer reachable. 
				
			2. Eligibility for garbage collection: 
					An object is said to be eligible for GC(garbage collection) if it is unreachable. After i = null, integer object 4 in the heap area is suitable for garbage collection in the above image.
					
		Ways to make an object eligible for Garbage Collector:
			1. Nullifying the reference variable
			2. Re-assigning the reference variable
			3. An object created inside the method
			
		Ways for requesting JVM to run Garbage Collector
				Once we make an object eligible for garbage collection, it may not destroy immediately by the garbage collector. Whenever JVM runs the Garbage Collector program, then only the object will be destroyed. But when JVM runs Garbage Collector, we can not expect.
				
			1. Using System.gc() method: System class contain static method gc() for requesting JVM to run Garbage Collector.
			2. Using Runtime.getRuntime().gc() method: Runtime class allows the application to interface with the JVM in which the application is running. Hence by using its gc() method, we can request JVM to run Garbage Collector.
			
		Finalization:
			=> Just before destroying an object, Garbage Collector calls finalize() method on the object to perform cleanup activities. Once finalize() method completes, Garbage Collector destroys that object.
			
			=> finalize() method is present in Object class with the following prototype.
			
				protected void finalize() throws Throwable
			
			Based on our requirement, we can override finalize() method for performing our cleanup activities like close the resources or closing connection from the database.
			
			=>The finalize() method is called by Garbage Collector, not JVM. However, Garbage Collector is one of the modules of JVM.
			=>Object class finalize() method has an empty implementation. 
			=>The finalize() method is never invoked more than once for any object.
			=>If an uncaught exception is thrown by the finalize() method, the exception is ignored, and the finalization of that object terminates.
		
		Advantages of Garbage Collection in Java
			It makes java memory-efficient because the garbage collector removes the unreferenced objects from heap memory.
			It is automatically done by the garbage collector(a part of JVM), so we don’t need extra effort.
		

***************
16-OCT-2023
***************

Multi Tasking:
	The concept of executing multiple functionalities simultaneously one with the other is known as "Multi Tasking".
	
	In Multitasking multiple functions are executed simultaneously but not multiple statements.
	
	Advantages:
				Using multitasking we can avoid idle state of the CPU completely. 
				Idle state is that state of the CPU waiting for the execution of the I/O operations.
				Using multitasking we can make the functionalities independent of each other.

When do we go for multitasking?
	Whenever it is required to execute multiple functionalities simultaneously and independently and then show outputs of it simultaneously one with the other then only we apply the concept of multitasking in our java programming.
	Example :
				void animation(){
				//statements
				}
				
				void createAccount(){
				//statements
				}
				
				main(){
					animation();
					createAccount();
				}

				
Types of multitasking:
	There are two types of multitasking:            
		1. Process based multitasking            
		2. Thread based multitasking     
		
	1. Process based multitasking: 
		->The concept of executing the two different applications or programs of two different technologies simultaneously one with the other is known as process based multitasking.          
		->In this the control has to switch between the different environments or domains whose addresses are entirely different this increases overhead on the system.
		->This process based multitasking is not under the control of Java. So we can say this is not supported by Java.
		
    2. Thread based multitasking:
		->The concept of executing multiple functionalities belonging to the same application of the same technology simultaneously one with the other is known as Thread based multitasking.
		->In this the control would be switching between the two different functionalities belonging to the same application or domain because of which there wouldn't be any overhead on the system thus Java supports only Thread based multitasking.
		
What is a Thread? What is the difference between thread and function?

	-> Thread is nothing but a functionality which could be executed simultaneously or parallelly with the other part of the program.
	-> A Thread is a very light-weight subprocess, or we can say the smallest part of the process that allows a program to operate more efficiently by running multiple tasks simultaneously.
	
	-> From where as a method or function is also a functionality which would be executed hierarchically with the other part of the program based on certain order.
	
	->Thread executes one with the other (parallelly) but the method executes one after another (sequentially).

	Java Thread Benefits:
		-> In order to perform complicated tasks in the background, we used the Thread concept in Java.
		-> Java Threads are lightweight compared to processes, it takes less time and resources to create a thread.
		-> Threads share their parent process data and codeContext switching between threads is usually less expensive than between processes.
		-> Thread intercommunication is relatively easier than process communication.
		
What is a process? What is the relation between process and thread?
	-> A program (group of functions or collection of functions) is under execution is a process.
	-> Thread is a part of the process.
	-> A function under execution is not a process, it is a part of the process.
	
How to create a Thread in Java?    Java provides two ways to create a thread programmatically.   

	1. Implementing the java.lang.Runnable interface.
	2. Extending the java.lang.Thread class.
	
	1. Implementing the java.lang.Runnable interface:
		
		To make a class as a Thread, we can implement java.lang.Runnable interface and provide implementation of public void run() method. We need to create a Thread object by passing object of this runnable class and then call start() method to execute the run() method in a separate thread. 
		
		Example:
		
		syntax:
			public class ThreadA implements Runnable{
				public void run(){
					//Statements
				}
			}
			
			Thread thread = new Thread(new ThreadA());
			thread.start()
		
	2. Extending the java.lang.Thread class.
		We can extend java.lang.Thread class to create our own java thread class and override run() method. Then we can create it’s object and call start() method to execute our custom java thread class run method. 
	
		Example:
			public class ThreadB extends Thread{
				public void run(){
					//Statements
				}
			}

			ThreadB thread1 = new ThreadB();
			thread.start()
*****************
17-Oct-2023
*****************

Thread Class vs Runnable Interface 

	Runnable:																Thread:
													
	->It is an interface.										It is a class.
	->It can be used to create a thread.						It can be used to create a thread.
	->It has a single abstract method ‘run’.					It has multiple methods such as ‘start’ and ‘run’.
	->It requires less memory space.							It requires more memory space.
	->When a class implements the ‘runnable’ interface, 		Since multiple inheritance is not allowed in Java, 
		the class can extend to other classes.							hence, after a class extends the Thread class, it can’t extend to any other class.

The two steps of implementing thread based multitasking in Java:
	
Step 1:	We can define a functionality as a thread in Java either by implementing the run() of Runnable interface or overriding the run() of Thread class. 
		
Step 2: Calling the start() of a Thread class can execute the run() method as a thread.
			
			Note : If we call the run() directly it executes like a normal function.
			
start() of a thread class:
	The functionality of the start() is only to handover the run() to JVM for scheduling.
	
	scheduling: 
				-> JVM allocates the time for the processor to execute the run() (i.e. thread) and it decids when the execution of run() (i.e., thread) to start and which thread has to continue next is known as a scheduling.
				-> Output of any thread would be based on scheduling. Thus we can't predict exact output of a thread application.
				-> Actually scheduling is the process of the local OS where JVM utilises it.
				-> Scheduling is highly dynamic.
				-> Scheduling is not done based on first come first serve.

What is Multi Threading:

	=> The concept of defining multiple functionalities as threads and executing these functionalities simultaneously one with the other as threads is known as Multi Threading. Simply can say Multithreading in Java is a process of executing multiple threads simultaneously.
	
	=> Multithreading is a Java feature that allows concurrent execution of two or more parts of a program for maximum utilization of CPU. Each part of such program is called a thread. So, threads are light-weight processes within a process.
	
	=> Example:
		class ThreadA extends Thread{
			public void run(){
				// statements
			}
		}
		
		class ThreadB implements Runnable{
			public void run(){
				// statements
			}
		}
		
		class ThreadC extends Thread{
			public void run(){
				// statements
			}
		}
		
		class ThreadTest{
			psvm(){
				ThreadA t1=new ThreadA();
				Thread t2=new Thread(new ThreadB());
				ThreadC t3=new ThreadC();
				t1.start();
				t2.start();
				t3.start();
			}
		}
		
Suspending a thread in the middle of its execution:

	1. Suspending a thread based on time: 
		sleep(): 
				The sleep() method is used to stop the execution of the current thread(whichever might be executing in the system) for a specific duration of the time and after that time duration gets over, the thread which is executing earlier starts to execute again.
			
			-> It is a static method in Thread class 
			-> Suspending a thread in the middle of its execution for the mentioned period of time.
			-> syntax:
					try {
						Thread.sleep(5000); // Here should pass the time in milliseconds. passing 5 seconds
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				
			-> Which throw checked exception.
			
			Important Point Regarding Thread.sleep() Method:

				->Method Whenever Thread.sleep() functions to execute, it always pauses the current thread execution.
				->If any other thread interrupts when the thread is sleeping, then an InterruptedException will be thrown.
				->If the system is busy, then the actual time the thread will sleep will be more as compared to that passed while calling the sleep method.
				
	2. Suspending a thread based on the execution of another thread.
	
		Thread class provides the join() method which allows one thread to wait until another thread completes its execution. 
		
		t1
		run(){
			//Statements
		}
		
		t2
		run(){
			//Statements
		}
		
		If suppose Thread3 is dependent on Thread1 completion then we can use the join()
		
		t3
		run(){
			t3.join();
			//statements
		}
		
	3. suspending a thread unconditionally:
	
		
		suspend() and resume():
			suspend():This is a method used to suspend the thread. The thread will remain suspended and won’t perform its tasks until it is resumed.
			resume():This is a method used to resume the suspended thread.
			
			-> These 2 methods are deprecated, by using these methods the program can enter into a deadlock. So don't prefer it.
			-> Instead of these methods we can use the wait() & notify()

Thread Safe:

		When multiple threads are working on the same data, and the value of our data is changing, that scenario is not thread-safe and we will get inconsistent results. 
		When a thread is already working on an object and preventing another thread from working on the same object, this process is called Thread-Safety. 

		Synchronization:
			Synchronization is the process of allowing only one thread at a time to complete the particular task.
			It means when multiple threads are executing simultaneously, and want to access the same resource at the same time, then the problem of inconsistency will occur. so synchronization is used to resolve inconsistency problems by allowing only one thread at a time.
			
			synchronized is a keyword. We implement the concept of thread safety by using synchronized keyword.

			syntax:
			
			synchronized void methodA(){ //method level
				//Statements
			}
			
			or
			
			methodB(){
			//Statements
				synchronized(this){ // block level
				
				}
				or 
				synchronized(object){
				
				}
			//Statements
			}
			
*****************	
19-Oct-2023	
*****************

wait(),notify() & notifyAll():
	These are final methods defined in the Object class and can be called only from within a synchronized context.

wait():
		the wait() method causes the current thread to wait until another thread invokes the notify() or notifyAll() methods for that object.
		
notify(): 

		The notify() method wakes up a single thread that is waiting on that object’s monitor. 

		Wakes up a single thread that is waiting on this object's monitor. If any threads are waiting on this object, one of them is chosen to be awakened.
		
		notify() places a request to jvm for rescheduling, then the thread which is in wait state back into action state.
	
notifyAll():
		The notifyAll() method wakes up all threads that are waiting on that object’s monitor. 
		
volatile:
		The volatile keyword in Java is used to indicate that a variable's value may be modified by multiple threads simultaneously. It ensures that the variable is always read from and written to the main memory, rather than from thread-specific caches, ensuring visibility across threads.
		
		syntax:
			public class Comman{
				volatile boolean flag=true;
			}

Priorities:
	-> We use the priorities for controlling the rescheduling of threads when the threads are in wait sate.
	-> notify() would be notify the rescheduling based on the priorities of the threads mentioned.
	-> priorities ranges from 1 to 9. 
		1 is lowest priority.
		9 is higest priority.
	-> The priority is consider only at the time of rescheduling of threads.
	-> The default priority of any thread is always 5 because the priority of main thread is 5.
	-> If we don't sent any priority to a thread, automatically the priority of the parent thread is given to the child thread. 
	
		syntax:
			t1.setPriority(int);

yield():

	A yield() method is a static method of Thread class and it can stop the currently executing thread and will give a chance to other waiting threads of the same priority. If in case there are no waiting threads or if all the waiting threads have low priority then the same thread will continue its execution.

Daemon Threads:
	-> A thread which get suspended permanantely once the execution of its parent thread is completed is known as Daemon Thread.
	-> Garbage collector is the example for Daemon threads.
	-> Garbage collector is one of the thread which is working as soon as JVM starts executiion, once the execution of JVM is completed then automatically Garabage collector also terminated.
	
	syntax:
		t1.setDaemon(true);
			
Thread life Cycle:

	
*****************
26-Oct-2023
******************
Collections & Collection Framework:

	-> The Java Collections Framework is a library of classes and interfaces for working with collections of objects.
	-> The java.util.*; package contains all the classes and interfaces for the Collection framework.
	-> A collection is an object which can store other objects, called elements. Collections provide methods for adding and removing elements, and for searching for a particular element within the collection.
	-> Collection means group of elements
	-> Collection supports only objects.
	-> Collections don't support primitive data types.
	-> Collection changes dynamically.
	-> It has many library classes to represent or support a group of elements.
	-> Collection classes follow data structure.
	-> Any data structure contains a group of elements
	-> The way of arranging elements changes from data structure to data structure.

Difference between arrays and collections:

			Collections 													Arrays

		1. Collections are used to represent a group of elements. 		1. Arrays are used to represent a group of elements.
		2. Collections support only objects 							2. Arrays support both objects and primitive data type values.
			and don't support the primitive data type value.
		3. The size of the collection can change at runtime 			3. The size of the array is always fixed, so it can't change at runtime.
			Thus the size of the collection is always dynamic.
		4. There are many library classes representing different 		4. Arrays are predefined structures of jvm.
			kinds of collections.

Collections:
	-> Collection can hold homogeneous as well as heterogeneous data elements.
	-> Collections represent the data structures as we have many data structures and we also have many collection classes.
	-> Using objects of any collection class we can represent the group of elements.
	-> The procedure followed to maintain the group of elements is to arrange the group of elements within the collection object changes from collection class to collection class.
	-> All the collection classes are divided into three different types and there are:

	1. List collections
	2. Map collections
	3. Set collections

	-> All the collection classes would be supporting certain basic and fundamental operations like adding an element, accessing an element, removing an element and getting the size of the collection
		All these functionalities that are supposed to be supported by the collection classes are defined in an interface by name "Collection".

																Collection 
																	|
									___________________________________________________________________
									|								|								   |
									List 						  Queue		  						  Set 		

	ArrayList: 
				The ArrayList class implements the List interface. It uses a dynamic array to store the elements. 
				The ArrayList class maintains the insertion order and is non-synchronized.
				The ArrayList class maintains the duplicate elements.
				The elements stored in the ArrayList class can be randomly accessed. 
				If the array size reached to its capacity then its capacity is incremented by 50%.
				
				constructors:
					ArrayList();
					ArrayList(capacity);
					ArrayList(Collection);
				
				methods:
					add(element), add(index,element), size(), clear(), isEmpty(),ensureCapacity(newcapacity),remove(index),remove(element), contains(element)
				
				
--> accessing collection:
				
						1. for loop
						2. enhanced for loop
						3. iterator
						4. listIterator
						
					iterator:
						hasNext()	: return true if it has the next element otherwise false.
						next()		: returns the next element.
						remove()	: remove the element.
						
					listIterator:
						add(element)  	: adds the element to the list at the position just before the element that will be returned by the next call to the next() method.
						hasPrevious() 	: return true if the cursor having the previous element otherwise false.
						nextIndex()	  	: It returns the next index value.
						previous()		: returns the previous element from the list. If the iterator at the beginning of the list then it throws NoSuchElementException.
						previousIndex()	: returns previous index.
						set(element)	: replaces the element returned by the last call.
						
						
	LinkedList:
				LinkedList implements the List and Deque interface. It uses a doubly linked list internally to store the elements. It can store the duplicate elements. It maintains the insertion order and is not synchronized. In LinkedList, the manipulation is fast because no shifting is required.
				
				constructors:
					LinkedList();
					LinkedList(Collection);
				
				methods:
					add(element), add(index,element), size(), clear(), isEmpty(),ensureCapacity(newcapacity),remove(index),remove(element), contains(element)
					addFirst(element),addLast(element),
						
				
	Difference between ArrayList & LinkedList:
	
								ArrayList																	LinkedList
					
	1. This class uses a dynamic array to store the elements in it. 				1. This class uses a doubly linked list to store the elements in it.
	2. Manipulation with ArrayList is slow because it internally uses an array. 	2. Manipulation with LinkedList is faster than ArrayList 
		If any element is removed from the array, 										because it uses a doubly linked list, so no shifting is required in memory.
		all the other elements are shifted in memory.
	3. An ArrayList class can act as a list only because it implements List only.	3. LinkedList class can act as a list and queue both 
																						because it implements List and Deque interfaces.	
	4. ArrayList is better for storing and accessing data.							4. LinkedList is better for manipulating data.
	5. Generally, when an ArrayList is initialized, 
		a default capacity of 10 is assigned to the ArrayList.						5. There is no case of default capacity in a LinkedList. 
																						In LinkedList, an empty list is created when a LinkedList is initialized.
																						
																						
	Vector:
			Vector is like the dynamic array which can grow its size. Unlike array, we can store n-number of elements in it as there is no size limit. It is a part of Java Collection framework since Java 1.2. It is found in the java.util package and implements the List interface, so we can use all the methods of List interface here.

			It is recommended to use the Vector class in the thread-safe implementation only. If you don't need to use the thread-safe implementation, you should use the ArrayList, the ArrayList will perform better in such case.

			The Iterators returned by the Vector class are fail-fast. In case of concurrent modification, it fails and throws the ConcurrentModificationException.

			constructors:
				Vector()
				Vector(Collection c)
				Vector(int initialCapacity)
				
			methods:
				capacity(),size(),add(element),add(index,element),clear(),isEmpty(),remove(index),removeElement(element),removeAll(Collection),addAll(Collection)
				

	It is similar to the ArrayList, but there are some differences-
		

								ArrayList																		Vector
	1. ArrayList is not synchronized.												1. Vector is synchronized.
	2. ArrayList increments 50% of current array size 								2. Vector increments 100% means doubles the array size 
		if the number of elements exceeds from its capacity.							if the total number of elements exceeds than its capacity.
	3. ArrayList is not a legacy class. It is introduced in JDK 1.2.				3. Vector is a legacy class.
	4. ArrayList is fast because it is non-synchronized.							4. Vector is slow because it is synchronized, 
	5. ArrayList uses the Iterator interface to traverse the elements.				5. A Vector can use the Iterator interface or Enumeration interface to traverse the elements.
	
	
Set Collection:
	
	The Set interface is present in java.util package and extends the Collection interface.
	It is an unordered collection of objects in which duplicate values cannot be stored.
	
	There are implementation classes for Set interface.
		-> HashSet
		-> LinkedHashSet
		-> TreeSet
		
	HashSet:
		Java HashSet class implements the Set interface,
		
		-> HashSet doesn't maintain the insertion order. When iterating through a HashSet the order is unpredictable.
		-> HashSet stores the elements by using a mechanism called hashing.
		-> HashSet contains unique elements only.
		-> HashSet allows null value.
		-> HashSet class is non synchronized.
		-> HashSet is the best approach for search operations.
		-> The initial default capacity of HashSet is 16, and the load factor is 0.75.
		
		constructors:
			-> HashSet()		: Constructs a new, empty set; the default initial capacity (16) and load factor (0.75).
			-> HashSet(Collection c)	:	Constructs a new set containing the elements in the specified collection.
			-> HashSet(int initialCapacity)	:	Constructs a new, empty set; It has the specified initial capacity and default load factor (0.75).
			-> HashSet(int initialCapacity, float loadFactor): Constructs a new, empty set; It has the specified initial capacity and the specified load factor.
			
		methods:
			-> add(element), clear(), 	contains(Object o), isEmpty(), iterator(), remove(Object o), size()
				
	LinkedHashSet:
		Java LinkedHashSet extends the HashSet class and implements the Set interface. 
		
		-> LinkedHashSet contains unique elements only like HashSet.
		-> LinkedHashSet maintains insertion order.
		-> LinkedHashSet using an iterator, the elements will be returned in the order in which they were inserted.
		-> LinkedHashSet provides all optional set operations and permits null elements.
		-> LinkedHashSet is non-synchronized.
		
		constructors:
			-> LinkedHashSet()		: Constructs a new, empty set; the default initial capacity (16) and load factor (0.75).
			-> LinkedHashSet(Collection c)	:	Constructs a new set containing the elements in the specified collection.
			-> LinkedHashSet(int initialCapacity)	:	Constructs a new, empty set; It has the specified initial capacity and default load factor (0.75).
			-> LinkedHashSet(int initialCapacity, float loadFactor): Constructs a new, empty set; It has the specified initial capacity and the specified load.
			
		methods:
			-> add(element), clear(), 	contains(Object o), isEmpty(), iterator(), remove(Object o), size()
			
	TreeSet:
		TreeSet is the implementations of the SortedSet interface.
		
		-> TreeSet class contains unique elements only like HashSet.
		-> TreeSet is basically an implementation of a self-balancing binary search tree.
		-> The elements are ordered using their natural ordering
		-> TreeSet class access and retrieval times are quiet fast.
		-> TreeSet class doesn't allow null element.
		-> TreeSet class is non synchronized.
		-> TreeSet class maintains ascending order.
		
		constructors:
			TreeSet(): Constructs a new, empty tree set.
			TreeSet(Collection c)	: Constructs a new tree set containing the elements in the specified collection, sorted according to the natural ordering of its elements.
			TreeSet(Comparator comparator)	:	Constructs a new, empty tree set, sorted according to the specified comparator.
			TreeSet(SortedSet s)	:	Constructs a new tree set containing the same elements and using the same ordering as the specified sorted set.
			
		methods:
			-> add(element),  clear(), first(), last(), tailSet()
			
Difference between List & Set:
	
					List															Set
		1. The List is an indexed sequence.										1. The Set is an non-indexed sequence.
		2. List allows duplicate elements.										2. Set doesn’t allow duplicate elements.
		3. Elements by their position can be accessed.							3. Position access to elements is not allowed.
		4. Multiple null elements can be stored.								4. Null element can store only once.
		5. List implementations are ArrayList, LinkedList, Vector, Stack		5. Set implementations are HashSet, LinkedHashSet, TreeSet.


Map:
*****
		Map in an interface available in java.util package and it stores the data in key and value pairs. It does not allow duplicate keys.	
		
	There are implementation classes for Map interface.
		-> HashMap 
		-> LinkedHashMap
		-> TreeMap
		-> Hashtable
		
	HashMap:
	********
			HashMap class implements the Map interface which allows to store data in key and value pair, where keys should be unique. If you try to insert the duplicate key, it will replace the element of the corresponding key.
			
			To successfully store and retrieve objects from a HashMap, the objects used as keys must implement the hashCode method and the equals method.  
			
			-> HashMap contains values based on the key.
			-> HashMap contains only unique keys.
			-> HashMap may have one null key and multiple null values.
			-> HashMap uses the Hashing technique.
			-> HashMap is non synchronized.
			-> HashMap don't maintains any order.
			-> The initial default capacity of Java HashMap class is 16 with a load factor of 0.75.
			
			constructors:
				HashMap()		:			It is used to construct a empty HashMap with default capacity 16 and load factor 0.75	
				HashMap(Map m)	:			Constructs a new HashMap with specified Map.
				HashMap(int capacity)	:	Constructs a new, empty HashMap. It has the specified initial capacity and default load factor 0.75.
				HashMap(int capacity, float loadFactor)	:	Constructs a new, empty HashMap. It has the specified initial capacity and specified load factor.
				
			methods:
				put(key,value), get(key), containsKey(key), containsValue(value), isEmpty(), remove(key), replace(key,value),entrySet(),keySet()
				
	
	LinkedHashMap:
	***************
		LinkedHashMap is just like HashMap with the additional feature of maintaining an order of elements inserted into it. 
		
		->	LinkedHashMap contains values based on the key.
		->	LinkedHashMap contains unique elements.
		->	LinkedHashMap may have one null key and multiple null values.
		->	LinkedHashMap is non synchronized.
		->	LinkedHashMap maintains insertion order.
		->	The initial default capacity of Java HashMap class is 16 with a load factor of 0.75.
		
		constructors:
				LinkedHashMap()		:			It is used to construct a empty HashMap with default capacity 16 and load factor 0.75	
				LinkedHashMap(Map m)	:			Constructs a new HashMap with specified Map.
				LinkedHashMap(int capacity)	:	Constructs a new, empty HashMap. It has the specified initial capacity and default load factor 0.75.
				LinkedHashMap(int capacity, float loadFactor)	:	Constructs a new, empty HashMap. It has the specified initial capacity and specified load factor.
				
			methods:
				put(key,value), get(key), containsKey(key), containsValue(value), isEmpty(), remove(key), replace(key,value),entrySet(),keySet()
				
	TreeMap:
	********
		TreeMap class implements the SortedSet interface which implement the Map interface. 
		The TreeMap is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used.
		
		->	TreeMap contains only unique elements.
		->	TreeMap cannot have a null key but can have multiple null values.
		->	TreeMap is non synchronized.
		->	TreeMap maintains ascending order.
		
		constructors:
			TreeMap()						:	It is used to construct an empty tree map that will be sorted using the natural order of its key.
			TreeMap(Comparator comparator)	:	It is used to construct an empty tree-based map that will be sorted using the comparator comp.
			TreeMap(Map m)					:	It is used to initialize a treemap with the entries from m, which will be sorted using the natural order of the keys.
			TreeMap(SortedMap m)			:	It is used to initialize a treemap with the entries from the SortedMap sm, which will be sorted in the same order as sm.
			
			methods:
				put(key,value), get(key), containsKey(key), containsValue(value), isEmpty(), remove(key), replace(key,value),entrySet(),keySet()
				
	Hashtable:
	************
		Java Hashtable class implements a hashtable, which maps keys to values. It inherits Dictionary class and implements the Map interface.
		Any non-null object can be used as a key or as a value.To successfully store and retrieve objects from a hashtable, the objects used as keys must implement the hashCode method and the equals method. 
		
		->	A Hashtable is an array of a list. Each list is known as a bucket. The position of the bucket is identified by calling the hashcode() method. A Hashtable contains values based on the key.
		->	Hashtable class contains unique elements.
		->	Hashtable class doesn't allow null key or value.
		->	Hashtable class is synchronized.
		->	The initial default capacity of Hashtable class is 11 whereas loadFactor is 0.75.
				
		constructors:
			Hashtable()									:	It creates an empty hashtable having the initial default capacity 11 and load factor 0.75.
			Hashtable(int capacity)						:	It accepts an integer parameter and creates a hash table that contains a specified initial capacity.
			Hashtable(int capacity, float loadFactor)	:	It is used to create a hash table having the specified initial capacity and loadFactor.
			Hashtable(Map t)							:	It creates a new hash table with the same mappings as the given Map.
			
			methods:
				put(key,value), get(key), containsKey(key), containsValue(value), isEmpty(), remove(key), replace(key,value),entrySet(),keySet()
				

Difference Between Hashmap and Hashtable

						Hashmap																Hashtable
			1.	No method is synchronized.										1. Every method is synchronized.
			2.	Multiple threads can operate simultaneously 					2. At a time only one thread is allowed to operate the Hashtable’s object. Hence it is thread-safe.
				and hence hashmap’s object is not thread-safe.
			3.	Threads are not required to wait 								3. It increases the waiting time of the thread and hence performance is low.
				and hence relatively performance is high.
			4.	Null is allowed for both key and value.							4. Null is not allowed for both key and value. Will get a null pointer exception.
			5.	It is introduced in the 1.2 version.							5. It is introduced in the 1.0 version.
			6. 	It is non-legacy.												6. It is a legacy.
		
		ConcurrentHashMap:
		*****************
			The ConcurrentHashMap class is introduced in JDK 1.5 belongs to java.util.concurrent package, which implements ConcurrentMap as well as to Serializable interface also. ConcurrentHashMap is an enhancement of HashMap as we know that while dealing with Threads in our application HashMap is not a good choice.
			
			-> The underlined data structure for ConcurrentHashMap is Hashtable.
			-> ConcurrentHashMap class is thread-safe i.e. multiple threads can operate on a single object without any complications.
			-> At a time any number of threads are applicable for a read operation without locking the ConcurrentHashMap object which is not there in HashMap.
			-> In ConcurrentHashMap, the Object is divided into a number of segments according to the concurrency level.
			-> The default concurrency-level of ConcurrentHashMap is 16.
			-> Inserting null objects is not possible in ConcurrentHashMap as a key or value.
			-> In ConcurrentHashMap, at a time any number of threads can perform retrieval operation.
				But while updating the element, the thread must lock the particular segment in which the thread wants to operate. 
				This type of locking mechanism is known as Segment locking or bucket locking. 
				
		WeakHashMap :
		*************
			WeakHashMap is an implementation of the Map interface. WeakHashMap is almost same as HashMap.
			if object is specified as key doesn’t contain any references- it is eligible for garbage collection even though it is associated with WeakHashMap.

	
		-> If we want we can make any collection object thread safe by following way:
		
			List list=Collections.synchronizedList(listObj);
			Set list=Collections.synchronizedSet(setOb);
			Map map = Collections.synchronizedMap(mapObj);

HashMap internals:
		
		Hashing: 	
				Transformation of a string characters (TEXT) to a shorted fixed-length value that represents original String. A shorter value help in indexing and faster searches.
				
				-> In Java every object has a method public int hashcode that will return a hash value for given object.
				-> If two objects are equal then their hashcodes also should be equal.
				-> If you are using your class as a key then should implement the equals and hashcode methods & your hashcode method should return robust hashcode so that no issues arises while working in maps. because HashMap uses hashcode internally. If the hash code is not consistant then we may not get proper value while look-up the values.

				-> 
					Node<K,V>[] table;
					
					each Node contains:
					
							-------------------
								Node
							-------------------
								int hash;
								K key;
								V value;
								Node<K,V> next;
							-------------------
							
				-> while we call put method what happens internally. 
					put(key,value);
					
					put(K k,V v){
					
						hash(k);
						index = hash & (n-1)
						
					}
					Here n is the initial capacity i.e., 16.
					
				-> for null keys index is zero.
				
				-> while we call get method what happens internally.
					get(K k){
						hash(key);
						index = hash & (n-1);
					}
					
				-> In Java8, when we have too many unequal keys which gives same hashcode(i.e, index)- when the number of items in hash bucket grows beyond certain threshold ( TREEIFY_THRESHOLD=8), content of that bucket switches from using linked list of Entry object to a balanced tree. This therotically improves the worst-case performance from O(n) to O(log n). A balanced tree is faster than linked list.
				
				-> Once Map size reaches to load factor then double the capacity and re-hashing happens.
		
			
****************************************************************************************
						JDBC ( Java Database Connectivity)

****************************************************************************************

Database:
	Database is the heart of any enterprise application because it is used to store and retrieve the data of the applications most efficiently.

	The following are the list of frequently used SQL commands to communicate with the DB to perform the respective DB operations.
	
		1. Creating a new table in the DB
			syntax:
					CREATE TABLE <table_Name>
					(
						 Column_Name1 <DataType>(width)
						,Column_Name2 <DataType>(width)
						-----
						,Column_NameN <DataType>(width)
					);
					
			Note : 
				-> All Data Types may not have the width property.
				-> No Two columns in the same table can have the same name.
					
			Example:
					CREATE TABLE EMP
					(
						 id 				number
						,name 				varchar2(30)
						,salary 			number(10,2)
						,joining_date 		date
						,address 			varchar2(50)
						,creation_time 		timestamp
						,modification_time 	timestamp
					);
					
		2. Inserting the Data:
			Syntax:
					INSERT INTO <Table_Nme>(COL1,COL2,....)
						VALUES(VALUE1,VALUE2,....)
					OR 
					INSERT INTO <Table_Name) 
						VALUES(VALUE,VALUE2,VALUE3...);
						
			Example:
				INSERT INTO EMP VALUES(1001,'Prakash',75000.00,'22-AUG-11','BANGALORE',CURRENT_TIMESTAMP,CURRENT_TIMESTAMP);
				INSERT INTO EMP VALUES(1002,'Rajesh',75000.00,'22-AUG-23','BANGALORE',CURRENT_TIMESTAMP,CURRENT_TIMESTAMP);
				
		3. Deleting the records:
			Syntax:
				DELETE FROM <TABLE_NAME>;	DELETE ALL THE ROWS
				DELETE FROM <TABLE_NAME> WHERE CONDITIONS; DELETE MATCHED ROWS
						
			Example:
				DELETE FROM EMP WHERE ID=1001;
				
		4. Updating the records:
			Syntax:
				UPDATE <TABLE_NAME> SET <COLUMN_NAME1>=VALUE1,<COLUMN_NAME2>=VALUE2 WHERE CONDITIONS;
				
			Example:
				UPDATE EMP SET SALARY=90000.00,modification_time=CURRENT_TIMESTAMP WHERE ID=1001;
						
		5. Selecting the records from the DB tables:
			Syntax:
				SELECT <COLUMN_NAME1>,<COLUMN_NAME2>....,<COLUMN_NAME-N> 
				FROM <TABLE_NAME> --> Without where condition fetches all the records from the table.
				 
				 or
				 
				SELECT <COLUMN_NAME1>,<COLUMN_NAME2>....,<COLUMN_NAME-N> 
				FROM <TABLE_NAME> 
				WHERE <column_name1>=value1 AND <column_name2>=value2;  --> fetches the records from the table based on conditions.
				
			Example:
				SELECT * FROM EMP;
				Or
				SELECT ID,NAME,SALARY FROM EMP WHERE ID=1001;
				

What is JDBC?
	JDBC is a technology to communicate with the DB through the Java Application to perform the DB operations.
	
	-> The Java application which is written by the user to communicate with the DB is called a "JDBC Application".
	-> Java provides some set of interfaces with the package called "java.sql", so that users can import and use these interfaces in the JDBC Application to communicate with any DB through the Java Application.
	->The following are the list of Interfaces available in the java.sql package.
		1. Connection
		2. Statement
		3. ResultSet
		4. PreparedStatement
		5. CallableStatement
		6. ResultSetMetaData
		7. DataBaseMetaData
		
	-> Every interface is defined with the set of "abstract specification methods" related to the DB without any implementation details.
	-> The vendor of the DB will provide the implementation classes for all these classes which are called as "JDBC Driver Classes"
	-> JDBC Driver objects will act as intermediate objects between the java application & DB.
	-> The user can call the required vendor implemented methods available in the respective interface. Objective to perform the respective DB operations from the Java application.

JDBC Architecture:

	JDBC has the following components that are used for the interaction with the database.
	
		1. JDBC API
		2. JDBC Driver Manager
		3. JDBC Driver
		
		1) JDBC API: 
					JDBC API provides various interfaces and methods to establish easy connection with different databases.
					 javax.sql.*;
					 java.sql.*;
					 
		2) JDBC Driver manager: 
					JDBC Driver manager loads the database-specific driver into an application in order to establish the connection with the database. The JDBC Driver manager is also used to make the database-specific call to the database in order to do the processing of a user request.
					
		3) JDBC Drivers: 
					To interact with a data source with the help of the JDBC, one needs a JDBC driver which conveniently interacts with the respective data source.
					
					JDBC drivers are client-side adapters (installed on the client machine, not on the server) that convert requests from Java programs to a protocol that the DBMS can understand. 
					
				There are 4 types of JDBC drivers:
					Type-1 driver or JDBC-ODBC bridge driver
					Type-2 driver or Native-API driver
					Type-3 driver or Network Protocol driver
					Type-4 driver or Thin driver ( This is the driver currently using by all JDBC applications)
					
				-> Basically Database understands SQL.
				-> Java understand method calls.
				-> JDBC Driver translate java method calls to Database SQL statements.

	-> We should follow the below steps in every JDBC application to communicate with the DB.
	
		1. import of the packages
		2. Load Driver
		3. Register Driver
		4. Create Connection
		5. Create Statement
		6. Execute Statement
		7. Close
		
		Step 1:	importing the required interfaces.
		
				import java.sql.Connection;
				import java.sql.DriverManager;
				import java.sql.ResultSet;
				import java.sql.SQLException;
				import java.sql.Statement;
	
		Step 2: Load the Driver to our application by using following code.
		
				Before JDBC version 4 and Java SE 1.6 we were loading the driver class like below. but now it loads automatically.
				Class.forName("oracle.jdbc.OracleDriver");
				
		Step 3:
				Register Driver : This happens automatically at run time.
				
				DriverManager.registerDriver(new oracle.jdbc.OracleDriver());
				
		Step 4: Create the Connection by using the following code.
		
				Connection con=DriverManager.getConnection(connectionStr, username, password);
		
		Step 5:
				Create a Statement by using the following code.
				Statement st=con.createStatement();
				
		Step 6:
				Execute the statement
				ResultSet rs=st.executeQuery(sql);
				or 
				int count=st.executeUpdate(sql);
				
		Step 7: Closing the resources.
					rs.close();
					st.close();
					con.close();
					
		
		The statement interface is used to create SQL basic statements in Java it provides methods to execute queries with the database. There are different types of statements that are used in JDBC as follows:

		1. Statement
		2. PreparedStatement
		3. CallableStatement
		
		1. Statement :
				From the connection interface, you can create the object for this interface. It is generally used for general–purpose access to databases and is useful while using static SQL statements at runtime.
				
				Syntax:

					Statement statement = connection.createStatement();
					
			Implementation: Once the Statement object is created, there are three ways to execute it.
			
			boolean execute(String SQL): 
						It is used to execute SQL DDL statements or for dynamic SQL. If the ResultSet object is retrieved, then it returns true else false is returned. 
						Example: create table, alter table, etc. 
						
						In realtime, these kind of DDL operations do in databases by sql scripts. don't run from Java application.
			
			int executeUpdate(String SQL): 
					It is used to execute SQL DML statements, like INSERT, DELETE or UPDATE statements. It returns number of rows that are affected by the execution of the statement.
					
			ResultSet executeQuery(String SQL): 
					It is used to retrieve the data from database, basically to run the SQL SELECT. It returns a ResultSet object which holds the data that fetched from select query.
					
		2. PreparedStatement :
				Prepared Statement represents a compiled SQL statement once, that can be executed many times. This accepts parameterized SQL queries. In this, “?” is used instead of the parameter, one can pass the parameter dynamically by using the methods of PreparedStatement at run time.
				
				Example:

					PreparedStatement ps=con.prepareStatement("INSERT INTO EMP VALUES(?,?,?,?,?,?,?)");
					
								ps.setInt(1, 1001+i);
								ps.setString(2,"Rakesh");
								ps.setDouble(3, 9000.00);
				
				boolean execute(): This returns a boolean value and executes a static SQL statement that is present in the prepared statement object.
				boolean executeUpdate(): Returns the number of rows affected by the DML statements such as INSERT, DELETE, and more that is present in the current Prepared Statement.
				ResultSet executeQuery(): Returns a ResultSet from the current prepared statement.
				
		3. CallableStatement :
				CallableStatement interface is used to call the stored procedures and functions. 
				We can have business logic on the database by the use of stored procedures and functions that will make the performance better.
				
				Example to call the procedure:
					CallableStatement cs = con.prepareCall("{call fetch_emp_sal(?,?)}");
					cs.setInt(1, 1001);
					cs.registerOutParameter(2, Types.DOUBLE);
					cs.execute();
					Double sumSal=cs.getDouble(2);
					
				Example to call the function:
					
					CallableStatement cs = con.prepareCall("{?=call fetch_all_emp_sal(?)}");
					cs.registerOutParameter(1, Types.DOUBLE);
					cs.setInt(2, 1001);
					cs.execute();
					Double sumSal=cs.getDouble(1);
					
Batch processing:
		Batch Processing allows you to group related SQL statements into a batch and submit them with one call to the database.
		When you send several SQL statements to the database at once, you reduce the amount of communication overhead, thereby improving performance.
		
		The following methods are used for batch processing:
		
			addBatch() :
			  The addBatch() method of Statement, PreparedStatement, and CallableStatement is used to add individual statements to the batch. 
			  
			int[] executeBatch() :
				The executeBatch() is used to start the execution of all the statements grouped together. Which returns an array of integers, and each element of the array represents the update count for the respective update statement.
				
			clearBatch():
				This method removes all the statements you added with the addBatch() method.
